//! The DHCP client state module.

use std::{
    fmt,
    net::{
        SocketAddr,
        IpAddr,
        Ipv4Addr,
    },
    time::{
        Instant,
        Duration,
    },
};

use tokio::{
    timer::Delay,
};
use chrono::prelude::*;

use framed::DHCP_PORT_SERVER;

use backoff::Backoff;

/// Initial server response timeout in seconds.
const BACKOFF_TIMEOUT_INITIAL: u64 = 4;
/// Maximum server response timeout in seconds.
const BACKOFF_TIMEOUT_MAXIMUM: u64 = 64;
/// Is used if a server does not provide the `renewal_time` option.
const RENEWAL_TIME_FACTOR: f64 = 0.5;
/// Is used if a server does not provide the `rebinding_time` option.
const REBINDING_TIME_FACTOR: f64 = 0.875;

/// RFC 2131 DHCP states.
#[derive(Clone, Copy)]
pub enum DhcpState {
    Init,
    Selecting,
    Requesting,
    InitReboot,
    Rebooting,
    Bound,
    Renewing,
    Rebinding,
}

impl fmt::Display for DhcpState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use self::DhcpState::*;
        match self {
            Init => write!(f, "INIT"),
            Selecting => write!(f, "SELECTING"),
            Requesting => write!(f, "REQUESTING"),
            InitReboot => write!(f, "INITREBOOT"),
            Rebooting => write!(f, "REBOOTING"),
            Bound => write!(f, "BOUND"),
            Renewing => write!(f, "RENEWING"),
            Rebinding => write!(f, "REBINDING"),
        }
    }
}

/// Mutable `Client` data.
pub struct State {
    /// The destination address, usually the `255.255.255.255` broadcast address or a known server address.
    pub destination     : SocketAddr,
    /// Current DHCP client state (RFC 2131).
    pub dhcp_state      : DhcpState,
    /// Generated by client for each session.
    pub transaction_id  : u32,
    /// If the client requires broadcast response (e.g. if it is not configured yet).
    pub is_broadcast    : bool,

    /// DHCPOFFER receive deadline.
    pub timer_offer     : Option<Backoff>,
    /// DHCPACK or DHCPNAK receive deadline.
    pub timer_ack       : Option<Backoff>,
    /// Renewal timer (so called T1 in RFC 2131).
    pub timer_renewal   : Option<Delay>,
    /// Rebinding timer (so called T2 in RFC 2131).
    pub timer_rebinding : Option<Delay>,
    /// Lease expiration timer.
    pub timer_expiration: Option<Delay>,

    /// Recorded by the client from the selected `DHCPOFFER`.
    pub offered_address : Ipv4Addr,
    /// Recorded by the client from the selected `DHCPOFFER`.
    pub offered_time    : u32,
    /// Recorded by the client right before sending the `DhcpRequest`.
    pub requested_at    : u32,
    /// If set, the client has already selected a `DHCPOFFER` and only has to retransmit a `DHCPREQUEST`.
    pub dhcp_server_id  : Option<Ipv4Addr>,
    /// Recorded by the client from the `DhcpAck`.
    pub assigned_address: Ipv4Addr,
}

impl State {
    /// Constructs a default state.
    pub fn new(
        destination     : SocketAddr,
        dhcp_state      : DhcpState,
        is_broadcast    : bool,
    ) -> Self {
        State {
            destination,
            dhcp_state,
            transaction_id      : 0u32,
            is_broadcast,

            timer_offer         : None,
            timer_ack           : None,
            timer_renewal       : None,
            timer_rebinding     : None,
            timer_expiration    : None,

            offered_address     : Ipv4Addr::new(0,0,0,0),
            offered_time        : 0u32,
            requested_at        : 0u32,
            dhcp_server_id      : None,
            assigned_address    : Ipv4Addr::new(0,0,0,0),
        }
    }

    /// Sets T1, T2 (RFC 2131) and the lease expiration timer.
    pub fn set_timers(
        &mut self,
        renewal_time: Option<u32>,
        rebinding_time: Option<u32>,
        expiration_time: u32,
    ) {
        let renewal_after = (self.requested_at as u64) + renewal_time.unwrap_or(
            self.requested_at + (((expiration_time as f64) * RENEWAL_TIME_FACTOR) as u32)
        ) as u64 - (Utc::now().timestamp() as u64);
        self.timer_renewal = Some(Delay::new(Instant::now() + Duration::from_secs(renewal_after)));
        let rebinding_after = (self.requested_at as u64) + rebinding_time.unwrap_or(
            self.requested_at + (((expiration_time as f64) * REBINDING_TIME_FACTOR) as u32)
        ) as u64 - (Utc::now().timestamp() as u64);
        self.timer_rebinding = Some(Delay::new(Instant::now() + Duration::from_secs(rebinding_after)));
        let expiration_after = ((self.requested_at + expiration_time) as u64) - (Utc::now().timestamp() as u64);
        self.timer_expiration = Some(Delay::new(Instant::now() + Duration::from_secs(expiration_after)));
    }

    /// Sets the server IP address when it is known.
    pub fn set_destination(&mut self, ip: Ipv4Addr) {
        self.destination = SocketAddr::new(IpAddr::V4(ip),DHCP_PORT_SERVER);
    }

    /// Sets the `255.255.255.255` as a destination if the server IP address is unknown.
    pub fn set_destination_broadcast(&mut self) {
        self.destination = SocketAddr::new(
            IpAddr::V4(Ipv4Addr::new(255,255,255,255)),
            DHCP_PORT_SERVER,
        );
    }

    /// Moves the client from one state to another.
    ///
    /// Does not set state data, but does unset it if something
    /// must be unset in the beginning of the `to` state.
    pub fn transcend(&mut self, from: DhcpState, to: DhcpState) {
        use self::DhcpState::*;

        info!("Transcending from {} to {}", from, to);
        match from {
            Init => match to {
                Selecting => self.init_to_selecting(),
                _ => {},
            },
            Selecting => match to {
                Init => self.selecting_to_init(),
                Requesting => self.selecting_to_requesting(),
                _ => {},
            },
            Requesting => match to {
                Init => self.requesting_to_init(),
                Bound => self.requesting_to_bound(),
                _ => {},
            },

            InitReboot => match to {
                Rebooting => self.initreboot_to_rebooting(),
                _ => {},
            },
            Rebooting => match to {
                Init => self.rebooting_to_init(),
                InitReboot => self.rebooting_to_initreboot(),
                Bound => self.rebooting_to_bound(),
                _ => {},
            },

            _ => {},
        }
    }

    fn init_to_selecting(&mut self) {
        if self.timer_offer.is_none() {
            self.timer_offer = Some(Backoff::new(
                Duration::from_secs(BACKOFF_TIMEOUT_INITIAL),
                Duration::from_secs(BACKOFF_TIMEOUT_MAXIMUM),
            ));
        }
        self.dhcp_server_id = None;
        self.dhcp_state = DhcpState::Selecting;
    }

    fn selecting_to_init(&mut self) {
        self.dhcp_state = DhcpState::Init;
    }

    fn selecting_to_requesting(&mut self) {
        self.timer_offer = None;
        if self.timer_ack.is_none() {
            self.timer_ack = Some(Backoff::new(
                Duration::from_secs(BACKOFF_TIMEOUT_INITIAL),
                Duration::from_secs(BACKOFF_TIMEOUT_MAXIMUM),
            ));
        }
        self.dhcp_state = DhcpState::Requesting;
    }

    fn requesting_to_init(&mut self) {
        self.timer_offer = None;
        self.dhcp_server_id = None;
        self.dhcp_state = DhcpState::Init;
    }

    fn requesting_to_bound(&mut self) {
        self.timer_ack = None;
        self.dhcp_state = DhcpState::Bound;
    }

    fn initreboot_to_rebooting(&mut self) {
        if self.timer_ack.is_none() {
            self.timer_ack = Some(Backoff::new(
                Duration::from_secs(BACKOFF_TIMEOUT_INITIAL),
                Duration::from_secs(BACKOFF_TIMEOUT_MAXIMUM),
            ));
        }
        self.dhcp_state = DhcpState::Rebooting;
    }

    fn rebooting_to_init(&mut self) {
        self.timer_offer = None;
        self.dhcp_state = DhcpState::Init;
    }

    fn rebooting_to_initreboot(&mut self) {
        self.dhcp_state = DhcpState::InitReboot;
    }

    fn rebooting_to_bound(&mut self) {
        self.timer_ack = None;
        self.dhcp_state = DhcpState::Bound;
    }
}